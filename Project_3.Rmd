---
title: "BI_STAT_2021 Project_3"
date: "24/02/2021"
output:
  html_document:
    number_section: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
require(dplyr)
require(ggplot2)
require(car)
require(psych)
require(readxl)
require(cowplot)
require(multcomp)
require(vegan)
require(rgl)
require(scatterplot3d)
require(pca3d)
theme_set(theme_bw())
```

# Описание датасета 

## Предобработка данных 

```{r}
mouse_data <- read_xls('C:/Users/maxim/Desktop/Statistiks-and-R-programming/data/Data_Cortex_Nuclear.xls')
```

## Количество измерений 

Согласно описанию датасета, в экспериментах было зарегистрировано 15 измерений каждого белка на образец / мышь. То есть чтобы понять, сколько мышей было в эксперименте, необходимо поделить на 15 число всех строк, так как на каждую уникальную мышь имеется 15 отдельных измерений. 

```{r}
number_of_mouses <- nrow(mouse_data)/15
```

Получается, что в экспериментах приняло участие 72 мыши, что согласуется с описанием датасета. 

## Выделенные группы 

Ознакомившись с дальнейшим описанием датасете, можно узнать, что мыши условно разбиваются на 8 классов, на основании генотипа (контрольные (с) или трисомные (t) мыши), поведения(мыши, стимулированные к обучению (CS) и нет (SC)) и лечения(мемантин (m) или салин (s)). Информация о классе мыши содержится в последнем столбце датасета. Посмотрим распределение мышей по группам, составив таблицу (не забыв поделить на 15). 

```{r}
aggregate(cbind(count = MouseID) ~ class, 
          data = mouse_data, 
          FUN = function(x){NROW(x)/15})
```

Из этой таблицы можно понять, что, например, трисомных мышей, которых стимулировали к обучению и подвергали стимуляции мемантином в данном эксперименте было 9. Видим, что в целом представителей каждой из групп примерно поровну, то есть группы действительно достаточно сбалансированы. 

## Количество полных наблюдений 

Посчитаем количество полных наблюдений, то есть количество тех измерений, для которых есть данные по экпрессии всех белков, без пропущенных значений. 

```{r}
data_without_NA <- na.omit(mouse_data)
number_of_data_without_NA <- nrow(na.omit(mouse_data))
```

# Различия в уровне продукции BDNF_N

Для того, что проверить есть ли различия в уровне продукции данного белка в зависимости от класса, рассмотрим датафрейм без пропущенных значений экспрессии белка BDNF_N. Далее построим боксплоты для каждого класса и визуально оценим различия в экспрессии. 

```{r}
ggplot(mouse_data[!(is.na(mouse_data$BDNF_N)), ], aes(x=class, y=BDNF_N, fill=class))+
  geom_boxplot()+
  xlab("Класс мышей")+
  ylab("Экспрессия BDNF_N")+
  ggtitle("Различия в уровне продукции BDNF_N")+
  theme_bw()
```

Кажется, что мы действительно имеем некоторые значимые различия между первыми двумя классами и остальными. Однако, по данному графику мы не можем судить, от чего именно зависит продукция BFNF_N. В данном случае мы имеем 8 классов, созданных по 3 независимым признакам. Если мы хотим изучить, от чего именно меняется экспрессия данного белка, нам надо провести более подробный анализ, и выяснить, меняется ли экспрессия от какого-нибудь одного признака (например, от вида лечения) или от некоторой совокупности признаков. Для этого используем дисперсионный анализ, а затем проведем пост-хок тесты. 

```{r}
mouse_data$class <- as.factor(mouse_data$class)
model <- lm(BDNF_N ~ class, data = mouse_data)
a_model <- Anova(mod = model)
```

Однако, необходимо проверить рассматриваемые переменные на условия применимости дисперсионного анализа, а именно:

- нормальное распределение остатков
- гомогенность дисперсий остатков
- отсутствие коллинеарности (независимость групп)
- случайность и независимость наблюдений в группах

```{r}
simple_diag <- fortify(model) 

ggplot(simple_diag, aes(x = 1:nrow(simple_diag), y = .cooksd)) +
  geom_bar(stat = 'identity')
```

```{r}
ggplot(data = simple_diag, aes(x = class, y = .stdresid)) +
  geom_boxplot() + geom_hline(yintercept = 0)
```

```{r}
qqPlot(model, id = FALSE) 
```

В итоге, согласно всем проверкам мы действительно можем применить дисперсионный анализ. Посмотрим на его результаты. 

```{r}
a_model
```

По результатам дисперсионного анализа класс мыши значимо влияет на экспрессию белка BDNF_N (F = 18.816, p_value = 2.2e-16, Df = 7). Для того, чтобы определить как именно класс влияет на экспрессию белка проведем пост-хок тесты. 

```{r}
dat_tukey <- glht(model, linfct = mcp(class= 'Tukey'))
summary(dat_tukey)
```

Для наглядности, визуализируем этот результат. 

```{r}
MyData <-  expand.grid(class = data_without_NA$class)
MyData <- data.frame(MyData,
                   predict(model, newdata = MyData, interval = 'confidence'))
pos <- position_dodge(width = 0.2)
gg_linep <- ggplot(data = MyData, aes(x = class, y = fit,
                             ymin = lwr, ymax = upr)) + 
  geom_point(position = pos) +
  geom_errorbar(position = pos, width = 0.2) +
  xlab('Класс') + 
  ylab('Предсказанная продукция белка') +
  ggtitle('Предсказанные значения продукции BDNF_N в зависимости от класса')
gg_linep
```

Как итог, мы можем сказать, что для контрольных мышей, стимулированных к обучению, продукция белка была выше в независимости от лечения, чем у всех остальных классов. Для контрольных мышей, не стимулированных к обучению, продукция белка понижалась при стимуляции мемантином. Однако, не стимулированные к обучению трисомные мыши, которым вводился мемантин, имеют значительно более высокую продукцию белка, чем аналогичные контрольные мыши. Подобные результаты могут объяснены тем, что BDNF - белок, который относится к нейротрофинам, отвечающим за стимуляцию и поддерживание развития нейронов. В связи с этим его продукция действительно должна значимо различаться в подобном разбиении мышей по классам, так как эта классификация действительно предполагает разбиение по когнитивным способностям. Логично, что уровень продукции белка наиболее высок у здоровых мышей, которых стимулировали к обучению. 

# Линейная модель для предсказании продукции белка ERBB4_N в зависимости от продукции других белков

Исследуем, окажется ли удачной построение полной линейной модели для предсказания продукции ERBB4_N. Для этого возьмем датасет без пропущенных данных, в котором так же оставим только данные о продукции других белков. 

```{r}
ERBB4_mod <- lm(ERBB4_N ~ ., data = mouse_data[, -c(1, 79, 80, 81, 82)])
```

Произведем необходимый анализ с помощью функции fortify() из пакета ggplot. 

```{r}
mod_diag <- fortify(ERBB4_mod)
head(mod_diag)
```

## Проверка независимости наблюдений. 

```{r}
durbinWatsonTest(ERBB4_mod)
```

В данном случае значение критерия Дарбина-Уотсона меньше 2, то есть присутствует положительная автокорреляция. Значит, мы не можем сказать, что наблюдения в данном случае независимые.

## Проверка линейности взаимодействий и постоянства дисперсии. График остатков модели от предсказанных значений. 

```{r}
gg_resid <- ggplot(data = mod_diag, aes(x = .fitted, y = .stdresid)) + 
  geom_point() + 
  geom_hline(yintercept = 0)+
  geom_smooth(method = "lm") +
  geom_hline(yintercept = 2, color = "red") +
  geom_hline(yintercept = -2, color = "red") +
  ggtitle("График остатков для полной модели")
gg_resid  
```

В данном случае не очень много точек выбивается за пределы +/- 2 стандартных отклонений, то есть можно говорить, что нет больших проблем с линейностью взаимосвязи. Однако, на графике остатков наблюдается некоторая гетоскедактичность. 

## Проверка влиятельных наблюдений. График расстояний Кука.

```{r}
ggplot(mod_diag, aes(x = 1:nrow(mod_diag), y = mod_diag$.cooksd)) + 
  geom_bar(stat = "identity")+ 
  ggtitle("График расстояний Кука для полной модели")
```

Нельзя однозначно судить о присутствии большого числа влиятельных наблюдений. 

## Проверка на нормальность распеределения. График QQ-plot. 

```{r}
qqPlot(mod_diag$.fitted)
```

Определенно можно сказать, что большое число точек в правой и левой части распределения имеют завышенные значения относительно тех, какими они должны были бы быть в нормальном распределении. Иными словами, распределение вряд ли можно назвать нормальным. 

## Проверка на мультиколлениарность 

При попытке проверки модели на мультиколлениарность функцией vif возникают проблем с "идеальной мультиколлениарностью", то есть с переменными, которые линейно зависят от других. Посмотрев, с чем возникает проблема с помощью функции alias, уберем эти переменные из модели. 

```{r}
alias(ERBB4_mod)
```

```{r}
new_ERBB4_mod <- update(ERBB4_mod, .~. - pS6_N)
vif(new_ERBB4_mod)
```

Как итог, полная модель не является корректной, так как:

- распределение не является нормальным; 

- присутствует автокорреляция; 

- вероятно наблюдаются проблемы с наличием влиятельных наблюдений;

- многие предикторы зависимы друг от друга, то есть имеются проблемы с мультиколлениарностью. 

Последняя проблема наиболее значительная, показатель vif для огромного числа параметров очень большой. Вероятно, это связано с особенностями данных - в биологии часто экспрессия одного белка действительно напрямую зависит от другого, в случае, например, белков-регуляторов. Соответственно, из-за большого числа рассматриваемых параметров и мультиколлениарности между ними, линейная модель для данного случая не явлется удачным решением. Для более корректной работы необходимо уменьшить число переменных путем выполнения РСА. 

# РСА

```{r}
mouse_data_num <- data_without_NA %>% select_if(is.numeric)
mouse_pca <- rda(mouse_data_num, scale = TRUE)
head(summary(mouse_pca))
```

Итак, после проведения РСА построим графики ординации и посмотрим, какой в целом вклад вносит каждая компонента. 

## Ординация и графики факторных нагрузок 

Построим сначала биплот корреляций - где углы между векторами будут отражать корреляции признаков друг с другом и с осями главных компонент.

```{r}
biplot(mouse_pca, scaling = "species", display = "species")
```

Однако, такой график очень тяжело интерпретировать в нашем случае и с нашим количеством признаков. Тем не менее, можно сказать, что по первой компоненте почти все признаки имеют отрицательную нагрузку. 
Так же построим график ординации с помощью ggplot. 

```{r}
df_scores <- data.frame(data_without_NA,
scores(mouse_pca, display = "sites", choices = c(1, 2, 3), scaling = "sites"))

class_g <- ggplot(df_scores, aes(x = PC1, y = PC2)) + geom_point(aes(color = class), alpha = 0.5) +
coord_equal(xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2)) + ggtitle(label = "График ординации по классам") + theme_bw()

class_g
```

## Вклад каждой компоненты 

Посмотрим на собственные числа, а затем построим их график, на котором можно будет посмотреть, какое количество главных компонент вносит существенный вклад. 
```{r}
eigenvals(mouse_pca)
```




```{r}
screeplot(mouse_pca, type = "lines", bstick = TRUE)
```

В целом, 6 точек графика собстенных чисел лежат выше модели Broken Stick, поэтому в идеале именно в 6 главных компонент можно "свернуть" наши измерения. Однако, график больше, чем в трех измерениях, интерпретировать и построить будет достаточно затруднительно, поэтому построим для данной модели хотя бы трехмерный график в осях трех первых главных компонент. 

## Трехмерный график в осях трех первых главных компонент 

```{r}
pca_summary <- prcomp(mouse_data_num, scale=T)
pca3d(pca_summary)
snapshotPCA3d(file="3D_graph.png")
```



